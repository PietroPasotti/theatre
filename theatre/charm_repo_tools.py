import json
from pathlib import Path
from typing import Dict, Optional, Tuple

import yaml
from scenario import Context, Mount

from theatre.dialogs.edit_delta import DELTA_TEMPLATE
from theatre.config import TEMPLATES_DIR
from theatre.helpers import load_module
from theatre.logger import logger

LOADER_TEMPLATE = TEMPLATES_DIR / "loader_template.py"

SPEC_YAML_INSTRUCTIONS = """
# Add to this file, for each container your charm defines, the mounts you wish to be present in this initial situation.                        
# The initial contents of this file are autogenerated based on the containers we found in metadata.yaml
# example:

# traefik:
#  mounts:
#   /opt/boo: opt
#   /etc: baz

# this will mount into the (virtual, simulated) "traefik" container fs:
#  - `./opt` --> `/path/to/traefik-repo/.theatre/virtual_fs/default/traefik/opt/boo/`
#  - `./baz` --> `/path/to/traefik-repo/.theatre/virtual_fs/default/traefik/etc/`

# so if you touch a file `./traefik/baz/hw.yaml`, 
#  the charm will be able to `.get_container('traefik').pull('/etc/hw.yaml')`!
\n\n
"""


class InvalidLoader(RuntimeError):
    """Raised if the contents of .theatre/loader.py are invalid."""


class TheatreState:
    def __init__(self, theatre_dir: Path):
        self.file = theatre_dir / "state.json"

        self.current_scene_path: Optional[Path] = None

        if self.file.exists():
            self.reload()

    def reload(self):
        if not self.file.exists():
            logger.debug("cannot load state: state file does not exist")
            return

        raw = json.loads(self.file.read_text())
        current_scene_path = raw.get("current_scene_path")
        self.current_scene_path = (
            Path(current_scene_path) if current_scene_path else None
        )

    def save(self):
        self.file.write_text(
            json.dumps({"current_scene_path": str(self.current_scene_path)})
        )
        print(f"saved state to {self.file}")


class CharmRepo:
    def __init__(self, path: Path):
        self._root = path
        self.state = TheatreState(self.theatre_dir)

    @property
    def _charm_meta(self):
        return self.root / "metadata.yaml"

    @property
    def charm_meta(self) -> Optional[dict]:
        if not self._charm_meta.exists():
            return None
        return yaml.safe_load(self._charm_meta.read_text())

    @property
    def theatre_dir(self):
        return self.root / ".theatre"

    @property
    def virtual_fs(self):
        return self.theatre_dir / "virtual_fs"

    @property
    def deltas_template(self):
        return self.theatre_dir / "deltas_template.py"

    @property
    def root(self) -> Path:
        return self._root

    @property
    def is_valid(self):
        return all(
            expected_file.exists()
            for expected_file in [
                self.root / "metadata.yaml",
                self.root / "src" / "charm.py",
            ]
        )

    @property
    def is_initialized(self) -> bool:
        return self.theatre_dir.exists()

    @property
    def loader_path(self) -> Path:
        return self.theatre_dir / "loader.py"

    @property
    def scenes_dir(self) -> Path:
        return self.theatre_dir / "scenes"

    def has_loader(self) -> bool:
        return self.loader_path.exists()

    def mounts(self) -> Dict[str, Dict[str, Tuple[Mount, ...]]]:
        """Mapping from initial situation names to container names to mounts."""
        vfs_root = self.virtual_fs
        if not vfs_root.exists():
            logger.error(f"{self.virtual_fs} does not exist")
            return {}

        vfs_root = self.virtual_fs
        mts = {}

        for initial_sit in vfs_root.glob("*"):
            if not initial_sit.is_dir():
                logger.debug(f"skipping {initial_sit} as it is not a dir")
                continue

            mts[initial_sit.name] = {}

            for container in initial_sit.glob("*"):
                if not container.is_dir():
                    logger.debug(f"skipping {container} as it is not a dir")
                    continue

                spec_yaml = container / "spec.yaml"
                if not spec_yaml.exists():
                    logger.debug(
                        f"skipping {container} as it does not contain a spec.yaml file"
                    )
                    continue

                try:
                    mounts = yaml.safe_load(spec_yaml.read_text())[container.name][
                        "mounts"
                    ]
                except (yaml.YAMLError, KeyError):
                    logger.error(
                        f"spec.yaml does not contain a "
                        f"mounts definition for {container.name}",
                        exc_info=True,
                    )
                    mts[initial_sit.name][container.name] = {}
                    continue

                if not isinstance(mounts, dict):
                    logger.error(
                        "spec.yaml incorrectly formatted: 'mounts' value should be a dict."
                    )
                    mts[initial_sit.name][container.name] = {}
                    continue

                mts[initial_sit.name][container.name] = {
                    str(loc)
                    .replace("/", "-")
                    .strip("-"): Mount(loc, container.joinpath(src))
                    for loc, src in mounts.items()
                }
        return mts

    def initialize(self):
        if not self._charm_meta.exists():
            raise RuntimeError(
                f"invalid repo root: metadata.yaml not found in {self.root}"
            )

        self.theatre_dir.mkdir(parents=True)
        default_fs = self.virtual_fs.joinpath("default")
        default_fs.mkdir(parents=True)

        containers = self.charm_meta.get("containers", ())
        for container_name in containers:
            container_fs = default_fs / container_name
            container_fs.mkdir()

            container_fs.joinpath("spec.yaml").write_text(
                SPEC_YAML_INSTRUCTIONS
                + yaml.safe_dump({container_name: {"mounts": {}}})
            )

        loader_file = self.loader_path
        # todo: load charm type from charm.py and inject the import in the template
        loader_file.write_bytes(LOADER_TEMPLATE.read_bytes())
        print(
            f"created {loader_file}: put there your charm loader for this repo (mandatory)"
        )

        deltas_template = self.deltas_template
        deltas_template.write_bytes(DELTA_TEMPLATE.read_bytes())
        print(
            f"created {deltas_template}: put there your delta template for this repo (optional)"
        )

        self.state.file.write_text("{}")
        logger.info(f"created {self.state.file}")

        scenes = self.theatre_dir / "scenes"
        scenes.mkdir()
        logger.info(f"created {scenes}")
        self.state.reload()

    def load_context(self):
        return load_charm_context(self.root, self.loader_path)

    @property
    def current_scene(self) -> Path:
        current_scene_path = self.state.current_scene_path
        if current_scene_path and current_scene_path.exists():
            return current_scene_path

    @current_scene.setter
    def current_scene(self, path: Path):
        self.state.current_scene_path = path
        self.state.save()


def load_charm_context(
    root: Path, loader_path: Path = TEMPLATES_DIR / "loader_template.py"
):
    logger.info(f"Loading charm context from repo: {root}.")
    module = load_module(loader_path, add_to_path=[root / "lib", root / "src"])

    logger.info(f"imported module {module}.")
    context_getter = getattr(module, "charm_context", None)

    if not context_getter:
        raise InvalidLoader("missing charm_context function definition")

    if not callable(context_getter):
        raise InvalidLoader(
            f"{loader_path}::context_getter should be of type Callable[[], Context]"
        )

    try:
        ctx = context_getter()
    except Exception as e:
        raise InvalidLoader(
            f"{loader_path}::context_getter() raised an exception"
        ) from e

    if not isinstance(ctx, Context):
        raise InvalidLoader(
            f"{loader_path}::context_getter() returned {type(ctx)}: "
            f"instead of scenario.Context"
        )

    logger.info(
        f"Successfully loaded charm {ctx.charm_spec.charm_type} context from {loader_path}."
    )
    return ctx
